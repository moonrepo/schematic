---
source: crates/core/tests/setting_merge_test.rs
expression: pretty(container.impl_partial_merge())
---
fn merge(
    &mut self,
    context: &Self::Context,
    mut next: Self,
) -> std::result::Result<(), schematic::ConfigError> {
    match self {
        Self::A(ao) => {
            if let Self::A(ai) = next {
                *self = Self::A(a(ao.to_owned(), ai, context)?.unwrap_or_default());
            } else {
                *self = next;
            }
        }
        Self::B(ao) => {
            if let Self::B(ai) = next {
                *self = Self::B(b(ao.to_owned(), ai, context)?.unwrap_or_default());
            } else {
                *self = next;
            }
        }
        Self::C(ao, bo) => {
            if let Self::C(ai, bi) = next {
                if let Some((ao, bo)) = c(
                    (ao.to_owned(), bo.to_owned()),
                    (ai, bi),
                    context,
                )? {
                    *self = Self::C(ao, bo);
                } else {
                    *self = Self::C(Default::default(), Default::default());
                }
            } else {
                *self = next;
            }
        }
        Self::D(ao, bo) => {
            if let Self::D(ai, bi) = next {
                if let Some((ao, bo)) = d(
                    (ao.to_owned(), bo.to_owned()),
                    (ai, bi),
                    context,
                )? {
                    *self = Self::D(ao, bo);
                } else {
                    *self = Self::D(Default::default(), Default::default());
                }
            } else {
                *self = next;
            }
        }
        Self::E(ao) => {
            if let Self::E(ai) = next {
                *self = Self::E(e(ao.to_owned(), ai, context)?.unwrap_or_default());
            } else {
                *self = next;
            }
        }
        _ => {
            *self = next;
        }
    };
    Ok(())
}
