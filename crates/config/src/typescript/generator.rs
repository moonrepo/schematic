use super::converter::Type;
use super::LiteralType;
use crate::config::{Config, ConfigEnum, Meta};
use miette::IntoDiagnostic;
use std::collections::HashMap;
use std::fmt::{Debug, Display, Write};
use std::fs;
use std::path::PathBuf;
use std::str::FromStr;

/// Format of a TypeScript enum.
#[derive(Default)]
pub enum EnumFormat {
    /// Native enum: `enum Name { Foo, Bar }`
    Enum,
    /// Native enum with values: `enum Name { Foo = 'foo', Bar = 'bar' }`
    ValuedEnum,
    /// String union: `type Name = 'foo' | 'bar';`
    #[default]
    Union,
}

/// Format of a TypeScript object.
#[derive(Default)]
pub enum ObjectFormat {
    /// Interface: `interface Foo {}`
    #[default]
    Interface,
    /// Type alias: `type Foo = {};`
    Type,
}

/// Options to control the rendered TypeScript output.
#[derive(Default)]
pub struct TypeScriptGeneratorOptions {
    pub enum_format: EnumFormat,
    pub exclude_partial: bool,
    pub object_format: ObjectFormat,
}

enum Output<'cfg> {
    Field {
        name: String,
        value: Type,
        optional: bool,
    },

    Struct {
        name: &'cfg str,
        fields: Vec<Output<'cfg>>,
    },

    Enum {
        name: &'cfg str,
        fields: Vec<Output<'cfg>>,
    },
}

/// A generator that can render TypeScript types from schematic configurations.
pub struct TypeScriptGenerator<'cfg> {
    configs: HashMap<&'cfg str, &'cfg Meta>,
    outputs: Vec<Output<'cfg>>,
    output_file: PathBuf,
}

#[allow(clippy::only_used_in_recursion)]
impl<'cfg> TypeScriptGenerator<'cfg> {
    /// Create a new generator instance that will write to the provided file path.
    pub fn new<'new>(output_file: PathBuf) -> TypeScriptGenerator<'new> {
        TypeScriptGenerator {
            configs: HashMap::new(),
            outputs: vec![],
            output_file,
        }
    }

    /// Add a [`Config`] to be rendered.
    pub fn add<T: Config>(&mut self) -> &mut Self {
        let mut fields = vec![];

        for setting in T::META.fields {
            fields.push(Output::Field {
                name: setting.name.to_string(),
                value: Type::from_str(setting.kind).unwrap(),
                optional: setting.optional,
            });
        }

        self.outputs.push(Output::Struct {
            name: T::META.name,
            fields,
        });

        self.configs.insert(T::META.name, &T::META);

        self
    }

    /// Add a [`ConfigEnum`] to be rendered.
    pub fn add_enum<T: ConfigEnum + Debug + Display>(&mut self) -> &mut Self {
        let mut fields = vec![];

        for variant in T::variants() {
            fields.push(Output::Field {
                name: format!("{:?}", variant),
                value: Type::Literal(LiteralType::String(variant.to_string())),
                optional: false,
            });
        }

        self.outputs.push(Output::Enum {
            name: T::META.name,
            fields,
        });

        self.configs.insert(T::META.name, &T::META);

        self
    }

    /// Generate TypeScript types by rendering the [`Config`]s and [`ConfigEnum`]s
    /// in the order they were added, and writing them to the output file.
    pub fn generate(&self) -> miette::Result<()> {
        self.generate_with_options(TypeScriptGeneratorOptions::default())
    }

    /// Like [`TypeScriptGenerator.generate`], but with options to control the rendered output.
    pub fn generate_with_options(&self, options: TypeScriptGeneratorOptions) -> miette::Result<()> {
        let mut outputs = vec![
            "// Automatically generated by schematic. DO NOT MODIFY!".to_string(),
            "/* eslint-disable */".to_string(),
        ];

        for output in &self.outputs {
            outputs.push(
                self.render_output(output, false, &options)
                    .into_diagnostic()?,
            );

            if !options.exclude_partial && matches!(output, Output::Struct { .. }) {
                outputs.push(
                    self.render_output(output, true, &options)
                        .into_diagnostic()?,
                );
            }
        }

        if let Some(parent) = self.output_file.parent() {
            fs::create_dir_all(parent).into_diagnostic()?;
        }

        fs::write(&self.output_file, outputs.join("\n\n")).into_diagnostic()?;

        Ok(())
    }

    fn render_output(
        &self,
        output: &Output,
        partial: bool,
        options: &TypeScriptGeneratorOptions,
    ) -> Result<String, std::fmt::Error> {
        let mut buffer = String::new();

        match output {
            Output::Field {
                name,
                value,
                optional,
            } => {
                write!(buffer, "{}", name)?;

                if partial {
                    write!(buffer, "?")?;
                }

                write!(buffer, ": {}", value)?;

                if partial || *optional {
                    write!(buffer, " | null")?;
                }

                if matches!(options.object_format, ObjectFormat::Interface) {
                    write!(buffer, ";")?;
                } else {
                    write!(buffer, ",")?;
                }
            }
            Output::Struct { name, fields } => {
                let name = if partial {
                    format!("Partial{}", name)
                } else {
                    name.to_string()
                };

                if matches!(options.object_format, ObjectFormat::Interface) {
                    writeln!(buffer, "export interface {} {{", name)?;
                } else {
                    writeln!(buffer, "export type {} = {{", name)?;
                }

                for field in fields {
                    writeln!(buffer, "\t{}", self.render_output(field, partial, options)?)?;
                }

                write!(buffer, "}}")?;
            }
            Output::Enum { name, fields } => match options.enum_format {
                EnumFormat::Enum | EnumFormat::ValuedEnum => {
                    writeln!(buffer, "export enum {} {{", name)?;

                    for field in fields {
                        if let Output::Field { name, value, .. } = field {
                            if matches!(options.enum_format, EnumFormat::ValuedEnum) {
                                writeln!(buffer, "\t{} = {},", name, value)?;
                            } else {
                                writeln!(buffer, "\t{},", name)?;
                            }
                        }
                    }

                    write!(buffer, "}}")?;
                }
                EnumFormat::Union => {
                    write!(buffer, "export type {} = ", name)?;

                    for (i, field) in fields.iter().enumerate() {
                        if let Output::Field { value, .. } = field {
                            if i == fields.len() - 1 {
                                write!(buffer, "{}", value)?;
                            } else {
                                write!(buffer, "{} | ", value)?;
                            }
                        }
                    }

                    write!(buffer, ";")?;
                }
            },
        };

        Ok(buffer)
    }
}
