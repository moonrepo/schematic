use super::converter::Type;
use super::LiteralType;
use crate::config::{Config, ConfigEnum, ConfigMeta, MetaField};
use miette::IntoDiagnostic;
use std::collections::HashMap;
use std::fmt::Write;
use std::fs;
use std::path::PathBuf;
use std::str::FromStr;

#[derive(Default)]
pub enum ObjectType {
    #[default]
    Interface,
    Type,
}

#[derive(Default)]
pub struct TypeScriptGeneratorOptions {
    pub exclude_partial: bool,
    pub object_type: ObjectType,
}

pub enum Output<'cfg> {
    Field {
        name: &'cfg str,
        type_of: Type,
        optional: bool,
    },

    Struct {
        name: &'cfg str,
        fields: Vec<Output<'cfg>>,
    },

    Enum {
        name: &'cfg str,
        fields: Vec<Type>,
    },
}

pub struct TypeScriptGenerator<'cfg> {
    configs: HashMap<&'cfg str, &'cfg ConfigMeta>,
    outputs: Vec<Output<'cfg>>,
    output_file: PathBuf,
}

#[allow(clippy::only_used_in_recursion)]
impl<'cfg> TypeScriptGenerator<'cfg> {
    pub fn new<'new>(output_file: PathBuf) -> TypeScriptGenerator<'new> {
        TypeScriptGenerator {
            configs: HashMap::new(),
            outputs: vec![],
            output_file,
        }
    }

    pub fn add<T: Config>(&mut self) -> &mut Self {
        let mut fields = vec![];

        for setting in T::META.fields {
            match setting {
                MetaField::Setting {
                    name,
                    kind,
                    optional,
                } => {
                    fields.push(Output::Field {
                        name,
                        type_of: Type::from_str(kind).unwrap(),
                        optional: *optional,
                    });
                }
                MetaField::Nested {
                    name,
                    kind,
                    optional,
                } => {
                    fields.push(Output::Field {
                        name,
                        type_of: Type::from_str(kind).unwrap(),
                        optional: *optional,
                    });
                }
            }
        }

        self.outputs.push(Output::Struct {
            name: T::META.name,
            fields,
        });

        self.configs.insert(T::META.name, &T::META);

        self
    }

    pub fn add_enum<T: ConfigEnum>(&mut self) -> &mut Self {
        let mut fields = vec![];

        for variant in T::variants() {
            fields.push(Type::Literal(LiteralType::String(variant.to_string())));
        }

        self.outputs.push(Output::Enum {
            name: T::META.name,
            fields,
        });

        self.configs.insert(T::META.name, &T::META);

        self
    }

    pub fn generate(self) -> miette::Result<()> {
        self.generate_with_options(TypeScriptGeneratorOptions::default())
    }

    pub fn generate_with_options(self, options: TypeScriptGeneratorOptions) -> miette::Result<()> {
        let mut outputs = vec![
            "// Automatically generated by schematic. DO NOT MODIFY!".to_string(),
            "/* eslint-disable */".to_string(),
        ];

        for output in &self.outputs {
            outputs.push(
                self.render_output(output, false, &options)
                    .into_diagnostic()?,
            );

            if !options.exclude_partial && matches!(output, Output::Struct { .. }) {
                outputs.push(
                    self.render_output(output, true, &options)
                        .into_diagnostic()?,
                );
            }
        }

        if let Some(parent) = self.output_file.parent() {
            fs::create_dir_all(parent).into_diagnostic()?;
        }

        fs::write(&self.output_file, outputs.join("\n\n")).into_diagnostic()?;

        Ok(())
    }

    fn render_output(
        &self,
        output: &Output,
        partial: bool,
        options: &TypeScriptGeneratorOptions,
    ) -> Result<String, std::fmt::Error> {
        let mut buffer = String::new();

        match output {
            Output::Field {
                name,
                type_of,
                optional,
            } => {
                if partial {
                    write!(buffer, "{}?", name)?;
                } else {
                    write!(buffer, "{}", name)?;
                }

                write!(buffer, ": {}", type_of)?;

                if partial || *optional {
                    write!(buffer, " | null")?;
                }

                if matches!(options.object_type, ObjectType::Interface) {
                    write!(buffer, ";")?;
                } else {
                    write!(buffer, ",")?;
                }
            }
            Output::Struct { name, fields } => {
                let name = if partial {
                    format!("Partial{}", name)
                } else {
                    name.to_string()
                };

                if matches!(options.object_type, ObjectType::Interface) {
                    writeln!(buffer, "export interface {} {{", name)?;
                } else {
                    writeln!(buffer, "export type {} = {{", name)?;
                }

                for field in fields {
                    writeln!(buffer, "\t{}", self.render_output(field, partial, options)?)?;
                }

                write!(buffer, "}}")?;
            }
            Output::Enum { name, fields } => {
                write!(buffer, "export type {} = ", name)?;

                for (i, field) in fields.iter().enumerate() {
                    if i == fields.len() - 1 {
                        write!(buffer, "{}", field)?;
                    } else {
                        write!(buffer, "{} | ", field)?;
                    }
                }

                write!(buffer, ";")?;
            }
        };

        Ok(buffer)
    }
}
