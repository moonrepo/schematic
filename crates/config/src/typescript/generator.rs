use super::converter::Type;
use super::renderer::{render_output, Output};
use crate::config::{Config, MetaField};
use miette::IntoDiagnostic;
use std::fs;
use std::path::PathBuf;
use std::str::FromStr;

pub struct TypeScriptGenerator {
    outputs: Vec<Output>,
    output_file: PathBuf,
}

impl TypeScriptGenerator {
    pub fn new(output_file: PathBuf) -> Self {
        Self {
            outputs: vec![],
            output_file,
        }
    }

    pub fn add<T: Config>(&mut self, _: T) -> miette::Result<&mut Self> {
        let mut fields = vec![];

        for setting in T::META.fields {
            match setting {
                MetaField::Setting {
                    name,
                    kind,
                    optional,
                } => {
                    fields.push(Output::Field {
                        name: name.to_string(),
                        type_of: Type::from_str(&kind.to_string()).unwrap(),
                        optional: *optional,
                    });
                }
                MetaField::Nested {
                    name,
                    kind,
                    optional,
                } => {
                    fields.push(Output::Field {
                        name: name.to_string(),
                        type_of: Type::from_str(&kind.to_string()).unwrap(),
                        optional: *optional,
                    });
                }
            }
        }

        self.outputs.push(Output::Struct {
            name: T::META.name.to_string(),
            fields,
        });

        Ok(self)
    }

    pub fn generate(self) -> miette::Result<()> {
        let mut outputs = vec![
            "// Automatically generated by schematic. DO NOT MODIFY!".to_string(),
            "/* eslint-disable */".to_string(),
        ];

        for output in &self.outputs {
            outputs.push(render_output(output, false).into_diagnostic()?);

            if matches!(output, Output::Struct { .. }) {
                outputs.push(render_output(output, true).into_diagnostic()?);
            }
        }

        if let Some(parent) = self.output_file.parent() {
            fs::create_dir_all(parent).into_diagnostic()?;
        }

        fs::write(&self.output_file, outputs.join("\n\n")).into_diagnostic()?;

        Ok(())
    }
}
